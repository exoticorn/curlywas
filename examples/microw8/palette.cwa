import "env.memory" memory(4);

import "env.pow" fn pow(f32, f32) -> f32;
import "env.sin" fn sin(f32) -> f32;
import "env.cos" fn cos(f32) -> f32;
import "env.atan2" fn atan2(f32, f32) -> f32;
import "env.tan" fn tan(f32) -> f32;
import "env.atan" fn atan(f32) -> f32;
import "env.rectangle" fn rect(f32, f32, f32, f32, i32);

//export fn tic(time: i32) {
//    let i: i32;
//    loop pixels {
//        let lazy x = (i % 320) as f32 - 160.5;
//        let lazy y = (i / 320 - 120) as f32;
//
//        let lazy dist = 4000 as f32 / sqrt(x*x + y*y + 10 as f32);
//        let lazy angle = atan2(x, y) * (64.0 / 3.141);
//
//        i?120 = ((((dist + time as f32 / 63 as f32) as i32 ^ angle as i32) #% 32 + 32) >> ((dist as i32 - i % 7 * 3) / 40)) + 192;
//
//        branch_if (i := i + 1) < 320*240: pixels;
//    }
//}

export fn tic(time: i32) {
    let i: i32;
    loop colors {
        rect((i % 16 * 15) as f32, (i / 16 * 15) as f32, 15 as f32, 15 as f32, i);
        branch_if (i := i + 1) < 256: colors
    }
}

start fn gen_palette() {
    let i: i32 = 12*16*3-1;
    let avg: f32;
    loop gradients {
        let lazy scale = (i % 48) as f32 / 48 as f32;
        let inline angle = i as f32 * (3.1416 / 1.5 - 3.1416 / (11.0 * 16.0 * 1.5));
        let lazy c = 0.4 - cos(angle);
        let inline ulimit = avg + 0.8;
        let inline llimit = avg - 0.8;
        let lazy a = max(llimit, min(ulimit, c)) * (scale + 0.05);
        let lazy b = scale * scale * 0.8;
        let inline v = (select(i < 11*16*3, max(0 as f32, min(a + b - a * b, 1 as f32)), scale) * 255 as f32) as i32;
        (i%3 + i/3*4)?(120+320*240) = v;
        avg = (avg + c) * 0.5;

        branch_if i := i - 1: gradients;
    }

    i = 255;
    loop expand_sweetie {
        let lazy channel = i & 3;
        let lazy index = i >> 2;
        let lazy first_step = index >= 32;
        let inline src1 = select(first_step, index % 32 / 2, index * 2);
        let inline src2 = select(first_step, (index + 1) % 32 / 2, index * 2 + 1);
        let inline c1 = (src1 * 4 + channel)?(120+320*240+192*4);
        let inline c2 = (src2 * 4 + channel)?(120+320*240+192*4);
        i?(120+320*240+192*4) = (c1 + c2) * (3 + first_step) / 8;

        branch_if (i := i - 1) >= 0: expand_sweetie;
    }
}

data 120+320*240+192*4 {
    i32(
        0x2c1c1a,
        0x5d275d,
        0x533eb1,
        0x577def,
        0x75cdff,
        0x70f0a7,
        0x64b738,
        0x797125,
        0x6f3629,
        0xc95d3b,
        0xf6a641,
        0xf7ef73,
        0xf4f4f4,
        0xc2b094,
        0x866c56,
        0x573c33
    )
}
