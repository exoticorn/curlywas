import "env.memory" memory(4);

import "env.pow" fn pow(f32, f32) -> f32;
import "env.sin" fn sin(f32) -> f32;
import "env.cos" fn cos(f32) -> f32;
import "env.rectangle" fn rect(f32, f32, f32, f32, i32);

export fn tic(time: i32) {
    let i: i32;
    loop colors {
        rect((i % 16 * 15) as f32, (i / 16 * 15) as f32, 15 as f32, 15 as f32, i);
        branch_if (i := i + 1) < 256: colors
    }
}

fn fcol(v: f32) -> i32 {
    let lazy vi = v as i32;
    select(vi < 0, 0, select(vi > 255, 255, vi))
}

fn col(f: f32, c: f32) -> i32 {
    let lazy a = f * (c * -0.8 + 0.6);
    let lazy b = f * f * 0.7;
    fcol((a + b - a * b) * 255 as f32)
}

fn make_gradient(r: f32, g: f32, b: f32, base: i32) {
    let i: i32;
    loop colors {
        let f = (i + 1) as f32 / 16 as f32;
        ((base + i) * 4)!(120+320*240) =
            col(f, r) +
            (col(f, g) << 8) +
            (col(f, b) << 16);
        
        branch_if (i := i + 1) < 16: colors;
    }
}

start fn gen_palette() {
    let i: i32;
    loop hsv {
        let a = i as f32 * (3.141 / 6.0);
        make_gradient(sin(a) * 0.707 - cos(a) * 0.804, cos(a) * 0.816, cos(a) * 0.804 + sin(a) * 0.707, i * 16);
        branch_if (i := i + 1) < 11: hsv;
    }
    make_gradient(0 as f32, 0 as f32, 0 as f32, 11*16);
}